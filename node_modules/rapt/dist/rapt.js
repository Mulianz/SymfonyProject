// Creates a Redux middleware from the given sequence of transducers. Each
// transducer is a function that will be called with `(action, dispatch, read)`,
// where action and dispatch come from Redux, and `read` is a utility that reads
// data from the application store at the given path.
//
// Transducers are activated in order. If any of them returns a value different
// from the original action, the middleware chain is restarted from the
// beginning, passing the new value as an action. If undefined is returned, the
// current chain is stopped. If an array is returned, its elements will be
// dispatched in order, and the chain will wait on promises. If a promise is
// returned, its resulting value will be dispatched later.
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.createMiddleware = createMiddleware;

function createMiddleware() {
  for (var _len = arguments.length, transducers = Array(_len), _key = 0; _key < _len; _key++) {
    transducers[_key] = arguments[_key];
  }

  transducers.forEach(function (transducer) {
    if (typeof transducer !== 'function') {
      throw TypeError('Each transducer must be a function, got: ' + transducer);
    }
  });
  var transducer = combineTransducers.apply(undefined, transducers);

  return function (_ref) {
    var rootDispatch = _ref.dispatch;
    var getState = _ref.getState;

    var read = function read() {
      for (var _len2 = arguments.length, path = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        path[_key2] = arguments[_key2];
      }

      return readAtPath(getState(), path);
    };

    return function (nextDispatch) {
      return function (action) {
        if (action === undefined) return;
        var prev = action;
        action = transducer(action, rootDispatch, read);
        if (action === undefined) return;

        if (isPromise(action)) return action.then(rootDispatch);

        if (action instanceof Array) {
          var _ret = (function () {
            var bumper = undefined;

            action.forEach(function (step) {
              if (bumper) {
                bumper = bumper.then(function () {
                  return rootDispatch(step);
                });
              } else {
                step = rootDispatch(step);
                if (isPromise(step)) bumper = step;
              }
            });

            return {
              v: bumper
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }

        if (isPlainObject(action)) {
          if (action === prev) return nextDispatch(action);
          return rootDispatch(action);
        }

        return nextDispatch(action);
      };
    };
  };
}

/**
 * Utils
 */

function combineTransducers() {
  for (var _len3 = arguments.length, transducers = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    transducers[_key3] = arguments[_key3];
  }

  return function (action) {
    for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }

    var i = -1;
    while (++i < transducers.length) {
      var result = transducers[i].apply(transducers, [action].concat(args));
      if (result !== action) return result;
    }
    return action;
  };
}

// Safely reads a value from the given tree at the given path.
function readAtPath(tree, path) {
  if (!(path instanceof Array)) throw TypeError('path must be an array, got: ' + path);
  if (!path.length) return tree;

  var i = -1;
  while (++i < path.length) {
    if (isPrimitive(tree)) return undefined;
    var key = path[i];
    tree = tree[key];
  }

  return tree;
}

function isPrimitive(value) {
  return value == null || typeof value !== 'object' && typeof value !== 'function';
}

// If it quacks like a duck...
function isPromise(value) {
  return value != null && typeof value.then === 'function' && typeof value['catch'] === 'function';
}

function isPlainObject(value) {
  return !!value && (value.constructor === Object || !value.constructor);
}