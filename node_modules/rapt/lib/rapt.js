// Creates a Redux middleware from the given sequence of transducers. Each
// transducer is a function that will be called with `(action, dispatch, read)`,
// where action and dispatch come from Redux, and `read` is a utility that reads
// data from the application store at the given path.
//
// Transducers are activated in order. If any of them returns a value different
// from the original action, the middleware chain is restarted from the
// beginning, passing the new value as an action. If undefined is returned, the
// current chain is stopped. If an array is returned, its elements will be
// dispatched in order, and the chain will wait on promises. If a promise is
// returned, its resulting value will be dispatched later.
export function createMiddleware (...transducers) {
  transducers.forEach(transducer => {
    if (typeof transducer !== 'function') {
      throw TypeError(`Each transducer must be a function, got: ${transducer}`)
    }
  })
  const transducer = combineTransducers(...transducers)

  return ({dispatch: rootDispatch, getState}) => {
    const read = (...path) => readAtPath(getState(), path)

    return nextDispatch => action => {
      if (action === undefined) return
      const prev = action
      action = transducer(action, rootDispatch, read)
      if (action === undefined) return

      if (isPromise(action)) return action.then(rootDispatch)

      if (action instanceof Array) {
        let bumper

        action.forEach(step => {
          if (bumper) {
            bumper = bumper.then(() => rootDispatch(step))
          } else {
            step = rootDispatch(step)
            if (isPromise(step)) bumper = step
          }
        })

        return bumper
      }

      if (isPlainObject(action)) {
        if (action === prev) return nextDispatch(action)
        return rootDispatch(action)
      }

      return nextDispatch(action)
    }
  }
}

/**
 * Utils
 */

function combineTransducers (...transducers) {
  return (action, ...args) => {
    let i = -1
    while (++i < transducers.length) {
      const result = transducers[i](action, ...args)
      if (result !== action) return result
    }
    return action
  }
}

// Safely reads a value from the given tree at the given path.
function readAtPath (tree, path) {
  if (!(path instanceof Array)) throw TypeError(`path must be an array, got: ${path}`)
  if (!path.length) return tree

  let i = -1
  while (++i < path.length) {
    if (isPrimitive(tree)) return undefined
    const key = path[i]
    tree = tree[key]
  }

  return tree
}

function isPrimitive (value) {
  return value == null || typeof value !== 'object' && typeof value !== 'function'
}

// If it quacks like a duck...
function isPromise (value) {
  return value != null && typeof value.then === 'function' && typeof value.catch === 'function'
}

function isPlainObject (value) {
  return !!value && (value.constructor === Object || !value.constructor)
}
