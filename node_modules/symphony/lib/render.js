import {deepEqual} from 'emerge'

// Takes a component class, such as React.Component, and a prax. Returns a
// function that creates a subclass of this component from a vanilla JavaScript
// function. The resulting component is reactive: if the function accesses the
// prax data, the component will automatically update when that data is changed.
// See examples in docs.
export function createAuto (Component, prax, send) {
  const {autorun, stop, read} = prax

  return function auto (renderFunc) {
    return class extends Component {
      componentWillUnmount () {
        stop(this._next)
      }

      // Works best for minimal props, like object ids.
      shouldComponentUpdate (props) {
        return !deepEqual(props, this.props)
      }

      _render () {
        this._dom = renderFunc(this.props, read, send)
      }

      render () {
        stop(this._next)
        this._next = duo(this._render, this.forceUpdate, this)
        autorun(this._next)
        return this._dom
      }
    }
  }
}

// Creates a decorator that makes the decorated component class reactive
// relative to the given prax. If it accesses the prax data in its `render`
// method, it's going to be automatically updated when the data is changed. See
// examples in docs.
export function createReactiveRender (prax) {
  const {autorun, stop} = prax

  return function reactiveRender (Component) {
    return class extends Component {
      componentWillUnmount () {
        stop(this._next)
        if (typeof super.componentWillUnmount === 'function') {
          super.componentWillUnmount()
        }
      }

      _render () {
        this._dom = super.render()
      }

      render () {
        stop(this._next)
        this._next = duo(this._render, this.forceUpdate, this)
        autorun(this._next)
        return this._dom
      }
    }
  }
}

// Creates a decorator that makes the decorated method of a React component
// reactive relative to the given prax. The method is automatically called in
// `componentWillMount`; if it accesses the prax data, it's automatically rerun
// when the data is changed. See examples in docs.
export function createReactiveMethod (prax) {
  const {autorun, stop} = prax

  return function reactive (target, name, {value: func}) {
    if (typeof func !== 'function') return

    if (target.constructor && target.constructor !== Object) {
      // Probably a `React.Component`-derived class.
      const {componentWillMount: pre, componentWillUnmount: post} = target

      target.componentWillMount = function () {
        if (typeof pre === 'function') pre.call(this)
        if (!isBound(this[name])) this[name] = func.bind(this)
        autorun(this[name])
      }

      target.componentWillUnmount = function () {
        stop(this[name])
        if (typeof post === 'function') post.call(this)
      }

      return
    }

    // Probably an oldschool React class.
    if (typeof target.displayName === 'string') {
      if (!target.mixins) target.mixins = []

      target.mixins.push({
        componentWillMount () {
          autorun(this[name])
        },
        componentWillUnmount () {
          stop(this[name])
        }
      })
    }
  }
}

/**
 * Utils
 */

function isBound (func) {
  return typeof func === 'function' && (!func.prototype || /^bound\b/.test(func.name))
}

function duo (first, second, thisArg) {
  let i = 0
  return () => {
    i++
    if (i === 1) first.call(thisArg)
    else if (i === 2) second.call(thisArg)
  }
}
