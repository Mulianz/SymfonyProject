'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.createSymphony = createSymphony;

function _interopExportWildcard(obj, defaults) { var newObj = defaults({}, obj); delete newObj['default']; return newObj; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

var _prax = require('prax');

var _render = require('./render');

var _emerge = require('emerge');

_defaults(exports, _interopExportWildcard(_emerge, _defaults));

_defaults(exports, _interopExportWildcard(_prax, _defaults));

var _rapt = require('rapt');

_defaults(exports, _interopExportWildcard(_rapt, _defaults));

var _emit = require('./emit');

_defaults(exports, _interopExportWildcard(_emit, _defaults));

_defaults(exports, _interopExportWildcard(_render, _defaults));

function createSymphony(_ref) {
  var store = _ref.store;
  var Component = _ref.Component;

  if (!store || typeof store !== 'object' || typeof store.getState !== 'function' || typeof store.subscribe !== 'function') {
    throw Error('Expected a Redux store or an API-compatible alternative, got: ' + store);
  }

  var prax = (0, _prax.createPrax)(store.getState());
  store.subscribe(function () {
    prax.write(store.getState());
  });

  var symphony = {
    autorun: prax.autorun,
    stop: prax.stop,
    read: prax.read,
    reactiveMethod: (0, _render.createReactiveMethod)(prax),
    reactiveRender: (0, _render.createReactiveRender)(prax)
  };

  if (typeof Component === 'function') {
    symphony.auto = (0, _render.createAuto)(Component, prax, store.dispatch);
  }

  return symphony;
}