// Creates a synchronous event emitter in the form of a function. You can
// optionally specify a strict set of event names; they will be validated for
// both emitting and subscribing.
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.createEmitter = createEmitter;

function createEmitter() {
  var map = Object.create(null);

  for (var _len = arguments.length, eventNames = Array(_len), _key = 0; _key < _len; _key++) {
    eventNames[_key] = arguments[_key];
  }

  var strict = !!eventNames.length;
  if (strict) {
    eventNames.forEach(function (name) {
      if (typeof name !== 'string') {
        throw TypeError('Expected event name to be a string, got: ' + name);
      }
      map[name] = [];
    });
    Object.freeze(map);
  }

  function check(name) {
    if (strict) {
      if (!(name in map)) {
        throw Error('Event `' + name + '` not found in the list of permitted events: [' + Object.keys(map).join(', ') + ']');
      }
    } else {
      if (!map[name]) map[name] = [];
    }
    return map[name];
  }

  function emitter(name) {
    var subs = check(name);
    subs.forEach(function (sub) {
      sub();
    });
  }

  emitter.on = function (name, func) {
    var subs = check(name);
    if (typeof func === 'function') {
      if (! ~subs.indexOf(func)) subs.push(func);
    }
    return function () {
      var index = subs.indexOf(func);
      if (~index) subs.splice(index, 1);
    };
  };

  emitter.decorator = createDecorator(emitter);
  return emitter;
}

function createDecorator(emitter) {
  return function () {
    for (var _len2 = arguments.length, names = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      names[_key2] = arguments[_key2];
    }

    return function (target, methodName, definition) {
      var func = definition.value;

      if (typeof func !== 'function') return;

      // Probably a class derived from `React.Component`.
      if (target.constructor && target.constructor !== Object) {
        var _ret = (function () {
          var pre = target.componentWillMount;
          var post = target.componentWillUnmount;

          var unsubs = undefined;

          target.componentWillMount = function () {
            var _this = this;

            if (typeof pre === 'function') pre.call(this);
            if (!isBound(this[methodName])) this[methodName] = func.bind(this);
            unsubs = names.map(function (name) {
              return emitter.on(name, _this[methodName]);
            });
          };

          target.componentWillUnmount = function () {
            unsubs.forEach(function (unsub) {
              unsub();
            });
            if (typeof post === 'function') post.call(this);
          };

          return {
            v: undefined
          };
        })();

        if (typeof _ret === 'object') return _ret.v;
      }

      // Probably an oldschool React class.
      if (typeof target === 'object' && typeof target.displayName === 'string') {
        var _ret2 = (function () {
          if (!target.mixins) target.mixins = [];
          var unsubs = undefined;

          target.mixins.push({
            componentWillMount: function componentWillMount() {
              var _this2 = this;

              unsubs = names.map(function (name) {
                return emitter.on(name, _this2[methodName]);
              });
            },
            componentWillUnmount: function componentWillUnmount() {
              unsubs.forEach(function (unsub) {
                unsub();
              });
            }
          });

          return {
            v: undefined
          };
        })();

        if (typeof _ret2 === 'object') return _ret2.v;
      }

      // Probably a plain object whose purpose we don't know.
      if (!isBound(func)) func = definition.value = func.bind(target);
      names.map(function (name) {
        emitter.on(name, func);
      });
    };
  };
}

function isBound(func) {
  return typeof func === 'function' && (!func.prototype || /^bound\b/.test(func.name));
}