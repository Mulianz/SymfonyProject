'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.createAuto = createAuto;
exports.createReactiveRender = createReactiveRender;
exports.createReactiveMethod = createReactiveMethod;

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var _emerge = require('emerge');

// Takes a component class, such as React.Component, and a prax. Returns a
// function that creates a subclass of this component from a vanilla JavaScript
// function. The resulting component is reactive: if the function accesses the
// prax data, the component will automatically update when that data is changed.
// See examples in docs.

function createAuto(Component, prax, send) {
  var autorun = prax.autorun;
  var stop = prax.stop;
  var read = prax.read;

  return function auto(renderFunc) {
    return (function (_Component) {
      _inherits(_class, _Component);

      function _class() {
        _classCallCheck(this, _class);

        _Component.apply(this, arguments);
      }

      _class.prototype.componentWillUnmount = function componentWillUnmount() {
        stop(this._next);
      };

      // Works best for minimal props, like object ids.

      _class.prototype.shouldComponentUpdate = function shouldComponentUpdate(props) {
        return !(0, _emerge.deepEqual)(props, this.props);
      };

      _class.prototype._render = function _render() {
        this._dom = renderFunc(this.props, read, send);
      };

      _class.prototype.render = function render() {
        stop(this._next);
        this._next = duo(this._render, this.forceUpdate, this);
        autorun(this._next);
        return this._dom;
      };

      return _class;
    })(Component);
  };
}

// Creates a decorator that makes the decorated component class reactive
// relative to the given prax. If it accesses the prax data in its `render`
// method, it's going to be automatically updated when the data is changed. See
// examples in docs.

function createReactiveRender(prax) {
  var autorun = prax.autorun;
  var stop = prax.stop;

  return function reactiveRender(Component) {
    return (function (_Component2) {
      _inherits(_class2, _Component2);

      function _class2() {
        _classCallCheck(this, _class2);

        _Component2.apply(this, arguments);
      }

      _class2.prototype.componentWillUnmount = function componentWillUnmount() {
        stop(this._next);
        if (typeof _Component2.prototype.componentWillUnmount === 'function') {
          _Component2.prototype.componentWillUnmount.call(this);
        }
      };

      _class2.prototype._render = function _render() {
        this._dom = _Component2.prototype.render.call(this);
      };

      _class2.prototype.render = function render() {
        stop(this._next);
        this._next = duo(this._render, this.forceUpdate, this);
        autorun(this._next);
        return this._dom;
      };

      return _class2;
    })(Component);
  };
}

// Creates a decorator that makes the decorated method of a React component
// reactive relative to the given prax. The method is automatically called in
// `componentWillMount`; if it accesses the prax data, it's automatically rerun
// when the data is changed. See examples in docs.

function createReactiveMethod(prax) {
  var autorun = prax.autorun;
  var stop = prax.stop;

  return function reactive(target, name, _ref) {
    var func = _ref.value;

    if (typeof func !== 'function') return;

    if (target.constructor && target.constructor !== Object) {
      var _ret = (function () {
        // Probably a `React.Component`-derived class.
        var pre = target.componentWillMount;
        var post = target.componentWillUnmount;

        target.componentWillMount = function () {
          if (typeof pre === 'function') pre.call(this);
          if (!isBound(this[name])) this[name] = func.bind(this);
          autorun(this[name]);
        };

        target.componentWillUnmount = function () {
          stop(this[name]);
          if (typeof post === 'function') post.call(this);
        };

        return {
          v: undefined
        };
      })();

      if (typeof _ret === 'object') return _ret.v;
    }

    // Probably an oldschool React class.
    if (typeof target.displayName === 'string') {
      if (!target.mixins) target.mixins = [];

      target.mixins.push({
        componentWillMount: function componentWillMount() {
          autorun(this[name]);
        },
        componentWillUnmount: function componentWillUnmount() {
          stop(this[name]);
        }
      });
    }
  };
}

/**
 * Utils
 */

function isBound(func) {
  return typeof func === 'function' && (!func.prototype || /^bound\b/.test(func.name));
}

function duo(first, second, thisArg) {
  var i = 0;
  return function () {
    i++;
    if (i === 1) first.call(thisArg);else if (i === 2) second.call(thisArg);
  };
}